# GetSeq.pl extracts different categories of DNA sequence and saves them in a list format.
# Copyright (C) 2001-2003 Robert G. Beiko

# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# seq-extract.pl extracts different categories of DNA sequence from input file(s). Sequence data and ORF 
# information are required, and can be presented in one of two formats:
#
# Format 1: CDS and sequence data found within a GenBank .gbk flat file.
# Format 2: Raw sequence in FASTA format, and a table of ORFs generated by the NGI website (www.neurogadgets.com)
#
# There are four different categories of DNA sequence:
#
# 1 - Coding sequence (found within open reading frames)
# 2 - Upstream intergenic sequence (found prior to the ORF start codon)
# 3 - 'Far' upstream intergenic sequence (upstream of one or two start codons, but non-overlapping 
#     with upstream sequence)
# 4 - Non-upstream intergenic sequence (non-coding sequence found between two convergently-transcribed genes)
#
# These types of sequence are identified by the letters C, U, F, and N.
#
# Command line: perl seq-extract.pl [-g gbk-file | -n seqfile ORFFILE] [outfile] [seqlen] (Cxxx) (Uxxx) (Fxxx) (Nxxx) 
#
# [gbk-file | seqfile ORFFILE] - A single argument identifying the Genbank flat file, or a pair of arguments
# naming the FASTA sequence file and the NGI ORF file.
#
# [outfile] - The name of the output file to generate.
#
# [seqlen] - The length of sequences to extract from the genome. Note that this value will affect the positioning
# of the far-upstream sequences as well as their length.
#
# (C|U|F|Nxxx) - The number of unique sequences to extract for each category. If the requested number of 
# sequences cannot be extracted, the maximum number available will be returned.
#
# WARNING: position values from NGI are modified by adding 1 to the start position and 4 to the end (to 
# include the stop codon). This is necessary for consistency with GenBank. Also note that NGI does not consider
# non-protein-coding (i.e., RNA) genes.
#
#
# Last revision: Version 2.1, January 20, 2003.

use strict;

my %base_hash = ('A', 0, 
	      'a', 0,
	     	'C', 1,
		'c', 1,
		'G', 2,
		'g', 2,
		'T', 3, 
		't', 3, );

my @base_code = ('A', 'C', 'G', 'T');

############################################# Subroutines #############################################

### Randomly choose an array element, pop it
sub CHOOSE ($) {
	my $arr_to_choose = shift;
	my $lastEl = @$arr_to_choose - 1;
	my $getHere = int rand ($lastEl + 1);
	@$arr_to_choose[$getHere, $lastEl] = @$arr_to_choose[$lastEl, $getHere];
	my $to_take = (pop @$arr_to_choose);
	return ($$to_take[0], $$to_take[1]);
}

sub GETORFS($$$$) {
	my @localORFtab = @{$_[0]}; # ORF table
	my $localSeq = $_[1]; # Ref to sequence
	my $localORFbin = $_[2]; # Ref to ORF bin
	my $localORFpass = $_[3]; # Ref to ORF pass value
	
	my $rowref;
	my $name; my $begin; my $end;
	my $ORFseq; my $putX;

	print STDOUT "Getting ORFs from sequence: \n";
	SHUFFLE_ARR(\@localORFtab); # Randomize the ORF table to reduce order-specific bias
	foreach $rowref (@localORFtab) { # First pass: get the ORFs and replace them with x's 
		$name = $rowref->[0]; 
		$begin = $rowref->[1]; 
		$end = $rowref->[2];
		if ($begin > $end) { # ORF is backwards wrt genome file, need revcomp
			$ORFseq = REVCOMP (substr(${$localSeq}, $end, $begin - $end));
			for $putX ($end..$begin) { substr(${$localSeq}, $putX - 1, 1) = 'X'; }
		} else { # ORF is in forward sequence
			$ORFseq = uc (substr(${$localSeq}, $begin, $end - $begin)); # Uppercase
			for $putX ($begin..$end) { substr(${$localSeq}, $putX - 1, 1) = 'X'; }
		}
		$ORFseq =~ s/1\w+//g;
		if (!($ORFseq =~ m/X/)) { # If this sequence hasn't already been stored in another overlapping ORF
			${$localORFbin}[${$localORFpass}][0] = $name;
			${$localORFbin}[${$localORFpass}][1] = $ORFseq;
			++${$localORFpass};
		}
	}
}

sub GETUPS($$$$$$$) {
	
	my @localORFtab = @{$_[0]}; # ORF table
	my $localSeq = $_[1]; # Ref to sequence
	my $localUPbin = $_[2]; # Ref to upstr bin
	my $localUPpass = $_[3]; # Ref to upstr pass value
	my $seqlen = $_[4]; # sequence length
	my $localProxySeq = $_[5]; # The proxy sequence (contains Z's for ORFs)
	my $minlen = $_[6]; # The minimum sequence length

	my $rowref;
	my $name; my $begin; my $end;
	my $upstrSeq; my $putX;

	my $firstBase;
	
	print STDOUT "Getting upstream regions: \n";
	SHUFFLE_ARR(\@localORFtab); # Randomize again!
	foreach $rowref (@localORFtab) { # Second pass: get the upstream regions, toss the ones that contain x's, and record the rest		
		$name = $rowref->[0];
		$begin = $rowref->[1];
		$end = $rowref->[2];
		if ($begin > $end) { # Sequence is reverse complement
			$firstBase = $begin;
			if (substr($$localProxySeq, $firstBase, $minlen) =~ m/Z/) { # Then don't add it 
# print STDOUT substr($$localProxySeq, $firstBase, $minlen), "Ack\n";
				$upstrSeq = "X";
			} else {
				$upstrSeq = REVCOMP (substr(${$localSeq}, $firstBase, $seqlen)); # Upstream seq is to the 'right' of the ORF
# print STDOUT $firstBase, "/", length $$localSeq, " ";
if ($firstBase + $seqlen < length $$localSeq) {
				substr(${$localSeq}, $firstBase + $seqlen, 1) = '1'; 
}
			}
#			for $putX ($firstBase..$firstBase + $seqlen - 1) { substr(${$localSeq}, $putX, 1) = 'X'; }
		} else { # Sequence is forward
			$firstBase = $begin - 1;
			if (substr($$localProxySeq, $firstBase - $minlen, $minlen) =~ m/Z/) { # Again, don't add it
# print STDOUT substr($$localProxySeq, $firstBase - $minlen, $minlen), "Ack\n";
				$upstrSeq = "X";
			} else {
				$upstrSeq = uc (substr(${$localSeq}, $firstBase - $seqlen, $seqlen)); # Upstream seq is to the 'left' of the ORF
				substr(${$localSeq}, $firstBase - $seqlen, 1) = '1'; 
			}
#			for $putX ($firstBase - $seqlen + 1..$firstBase) { substr(${$localSeq}, $putX, 1) = 'X'; }
		}
		if (!($upstrSeq =~ m/[X1]/)) {
			${$localUPbin}[${$localUPpass}][0] = $name;
			${$localUPbin}[${$localUPpass}][1] = $upstrSeq;
			++${$localUPpass};
		}
	}
}

sub procGBK ($$) {

	print STDOUT "Opening Genbank file: \n\n\n";

	my $gbh = $_[0]; # GenBank file handle
	my @ORF_list = ();
	my $sequence = "";

	my $count = 0;
	my $lookgene; my $lookproduct; my $pseud = 0;

	my $thisline; my $seqlet;

	while (<$gbh>) {
		if (m/\s((t|r)RNA|CDS)\s+(\d+)\.\.(\d+)/) { # Forward CDS
			$ORF_list[$count][1] = $3;
			$ORF_list[$count][2] = $4;
			$lookgene = <$gbh>;
			while (!($lookgene =~ m/\/gene/)) { 
				$lookgene = <$gbh>; 
				if ($lookgene =~ m/pseudo/) {$pseud = 1;}
			}
			if ($lookgene =~ m/\/gene\=\"(.+)\"/) {
				$ORF_list[$count][0] = $1;
				$ORF_list[$count][0] =~ s/\./_/g;
				$ORF_list[$count][0] .= "_";
			}
			$lookproduct = <$gbh>;
			while (!($lookproduct =~ m/\/product/)) { 
				$lookproduct = <$gbh>; 
				if ($lookproduct =~ m/pseudo/) {$pseud = 1;}
			}

			if ($lookproduct =~ m/\/product\=\"(.+)[\n]/) {
				$ORF_list[$count][0] .= $1;
				$ORF_list[$count][0] =~ s/\"//g;
				$ORF_list[$count][0] =~ s/[\s\(\)\;]/_/g;
				$ORF_list[$count][0] =~ s/\,/\+/g;
			} else { print STDOUT "Missed $lookproduct"; }
			if ($pseud == 1) { substr($ORF_list[$count][0], 0, 0) = "PSEUDO"; $pseud = 0; }
# print STDOUT $ORF_list[$count][0], "\n";
			++$count;
		}
		elsif (/\s((t|r)RNA|CDS)\s+complement\((\d+)\.\.(\d+)\)/) { # reverse complement CDS
			$ORF_list[$count][1] = $4;
			$ORF_list[$count][2] = $3;
			$lookgene = <$gbh>;
			while (!($lookgene =~ m/\/gene/)) { 
				$lookgene = <$gbh>; 
				if ($lookgene =~ m/pseudo/) {$pseud = 1;}
			}			
			if ($lookgene =~ m/\/gene=\"(.+)\"/) {
				$ORF_list[$count][0] = $1;
				$ORF_list[$count][0] =~ s/\./_/g;
				$ORF_list[$count][0] .= "_";
			}
			$lookproduct = <$gbh>;
			while (!($lookproduct =~ m/\/product/)) { 
				$lookproduct = <$gbh>; 
				if ($lookproduct =~ m/pseudo/) {$pseud = 1;}
			}
			if ($lookproduct =~ /\/product=\"(.+)[\n]/) {
				$ORF_list[$count][0] .= $1;
				$ORF_list[$count][0] =~ s/\"//g;
				$ORF_list[$count][0] =~ s/[\s\(\)\;]/_/g;
				$ORF_list[$count][0] =~ s/\,/\+/g;
			} else { print STDOUT "Missed $lookproduct"; }
			if ($pseud == 1) { substr($ORF_list[$count][0], 0, 0) = "PSEUDO"; $pseud = 0; }
# print STDOUT $ORF_list[$count][0], "\n";
			++$count;
		}
		elsif (/^BASE COUNT/) {
			if (<$gbh> =~ /^ORIGIN/) {
				$thisline = <$gbh>;
				while (!($thisline =~ /\/\//)) {
					$seqlet = $thisline;
					chomp $seqlet;
					$seqlet =~ s/[\d\s]//g;
					$sequence .= uc ($seqlet);
					$thisline = <$gbh>;
				}
			}
		}
	}
	# print STDOUT "Finished ", $#ORF_list, "\n";
	$_[1] = $sequence;
	return @ORF_list;
}

sub procNGI ($$$) {

	print STDOUT "Opening NGI file: \n";

	my $inseq = $_[0]; #sequence file
	my $inORF = $_[1]; #ORF file
	my @ORF_list = ();

	my $sequence = "";
	# read the sequence and store it
	my $header = <$inseq>;
	chop $header;

	my @seq = <$inseq>;
	my $na;
	chop @seq;
	for $na (@seq) {
		$sequence .= uc ($na);
	}
	
	$_[2] = $sequence;

	my $count = 0;
	my @ORF; my $name;
	
	while (<$inORF>) {
		@ORF = ();
		push (@ORF, split); # split the input string
		$ORF[1] =~ s/\(//; # Drop the parentheses
		$ORF[1] =~ s/\)//; # Drop the parentheses
		$name = join ('_', @ORF[3..$#ORF]);
		$name =~ s/\,/\+/g;
		$name =~ s/[\(\)]//g;
		if ($ORF[1] > $ORF[0]) { # ORF is forward w.r.t. genome
			 ++$ORF[0]; $ORF[1] += 4;
		} else { --$ORF[0]; $ORF[1] -= 4; } # ORF is reversed
		$ORF_list[$count][0] = $name;
		$ORF_list[$count][1] = $ORF[0];
		$ORF_list[$count][2] = $ORF[1];
 		# print STDOUT "$ORF_list[$count][0]  $ORF_list[$count][1]  $ORF_list[$count][2]\n";
		++$count; # print STDOUT "$count\n";
	}
	return @ORF_list;
}

sub REVCOMP($) {

	my $seq = reverse $_[0];
	my $size = length ($seq) - 1;
	my $comp; my $char; my $newchar;
	
	for $comp (0..$size) {
		$char = substr($seq, $comp, 1);
		if (!($char =~ m/[xX1zZ]/)) { # Then take the complementary nucleotide
			$newchar = $base_code[3 - $base_hash{$char}];
			substr($seq, $comp, 1) = $newchar;
		}
	}
	return $seq;
}
	
sub SHUFFLE_ARR($) { # Shuffle the contents of an array, based on fisher_yates_shuffle from Perl Cookbook
	my $i; my $j;
	my $arrShuf = $_[0];
	my $arrSize = $#{$arrShuf};
	for $i (0..$arrSize) {
		$j = int rand ($i + 1);
		if ($i != $j) { @$arrShuf[$i, $j] = @$arrShuf[$j, $i]; }
	}
}

$| = 1;

my $usage = "perl GetSeq.pl [-g gbk-file | -n seqfile ORFFILE] [outfile] [seqlen] (-O) (-C xxx) (-U xxx) (-F xxx) (-N xxx)";

my $num_args = scalar(@ARGV);

my $sequence = "";
my @ORF_table = ();

my $format;
my $nextarg;

my $minUpLen = 50; # Screen very short upstream regions, since they are likely to be non-leading operonic genes

### Read input files

if ($ARGV[0] eq '-g') { 
	$format = "GENBANK";
	open (INGBK, "$ARGV[1]") or die "Can't open $ARGV[1].\n";
	@ORF_table = procGBK(\*INGBK, $sequence);
	close (INGBK);
	$nextarg = 2;
} elsif ($ARGV[0] eq '-n') {
	$format = "NGI";
	open (INSEQ, "$ARGV[1]") or die "Can't open $ARGV[1].\n";
	open (INORF, "$ARGV[2]") or die "Can't open $ARGV[2].\n";
	@ORF_table = procNGI(\*INSEQ, \*INORF, $sequence);
	close (INSEQ);
	close (INORF);
	$nextarg = 3;
} else {
	die "Usage: $usage\n";
}

print STDOUT "First 10 nucleotides of sequence: ", substr($sequence, 0, 10), "\n";
print STDOUT "Number of ORFs: ", $#ORF_table, "\n";

### Read outfile name and extraction parameters

my $outfile = $ARGV[$nextarg++];
my $seqlen = $ARGV[$nextarg++];

my @numMembers = (0,0,0,0); # C, U, F, N

my $overlap = 0; # Default: no overlap permitted. This can be overridden with the '-O' flag.

while ($nextarg < $num_args) {
	if (($ARGV[$nextarg] eq '-C') || ($ARGV[$nextarg] eq '-c')) { ++$nextarg; $numMembers[0] += $ARGV[$nextarg++]; }
	elsif (($ARGV[$nextarg] eq '-U') || ($ARGV[$nextarg] eq '-u')) { ++$nextarg; $numMembers[1] += $ARGV[$nextarg++]; }
	elsif (($ARGV[$nextarg] eq '-F') || ($ARGV[$nextarg] eq '-f')) { ++$nextarg; $numMembers[2] += $ARGV[$nextarg++]; }
	elsif (($ARGV[$nextarg] eq '-N') || ($ARGV[$nextarg] eq '-n')) { ++$nextarg; $numMembers[3] += $ARGV[$nextarg++]; }
	elsif ($ARGV[$nextarg] eq '-O') { ++$nextarg; $overlap = 1; }
	else { print STDOUT "\nInvalid flag $ARGV[$nextarg] ignored.\n"; ++$nextarg; }
}

print STDOUT "Set sizes requested: C $numMembers[0]  U $numMembers[1]  F $numMembers[2]  N $numMembers[3]\n";

### Chop the sequence based on ORF table


my @ORF_bin = ();
my $ORF_pass = 0;
my @upstr_bin = ();
my $upstr_pass = 0;
my $proxy_seq = $sequence;
my @unused_bin = ();
my $unused_pass = 0;

if ($overlap == 0) { # Upstream seqs may not overlap with ORFs, so process ORFs first
	GETORFS(\@ORF_table, \$sequence, \@ORF_bin, \$ORF_pass);
	GETUPS(\@ORF_table, \$sequence, \@upstr_bin, \$upstr_pass, $seqlen, \$proxy_seq, $minUpLen);
} else { # Upstream seqs get priority, so process them first
	GETORFS(\@ORF_table, \$proxy_seq, \@unused_bin, \$unused_pass);
	$proxy_seq =~ s/[xX]/Z/g; # proxy_seq has Z's to indicate ORFs

# GETUPS(\@ORF_table, \$sequence, \@upstr_bin, \$upstr_pass, $seqlen, \$sequence, $minUpLen);
	GETUPS(\@ORF_table, \$sequence, \@upstr_bin, \$upstr_pass, $seqlen, \$proxy_seq, $minUpLen);
	GETORFS(\@ORF_table, \$sequence, \@ORF_bin, \$ORF_pass);
}

# open (SOUT, ">seqout.txt"); print SOUT $sequence; close(SOUT);

print STDOUT "Getting intergenic sequences: \n";

my @farup_bin = ();
my @nonup_bin = ();
my $findlen = $seqlen + 2;
while ($sequence =~ m/X([acgtACGT1]{$findlen,})X/g) { # Get each intergenic stretch of sequence
	my $theMatch = $1;
	my $seqStart = pos $sequence;
	if ($theMatch =~ m/1/) { # FARUP sequence
		$theMatch =~ s/1//g;
		push (@farup_bin, [ ($seqStart, $theMatch) ]);
	} else { # NONUP sequence
		push (@nonup_bin, [ ($seqStart, $theMatch) ]); 
	} 
}

print STDOUT "Sorting sequences: \n";

### Sort sequences into the appropriate category

my @outputList = ();
my @gotMembers = (0,0,0,0); # C, U, F, N
my $got_name; my $got_seq; my $take_len; 
my $start_pt; my $add_to_list; my $add_me;
my @frags;

ORFBLOCK: {
	while ($gotMembers[0] < $numMembers[0]) {
		($got_name, $got_seq) = CHOOSE (\@ORF_bin);
		$take_len = length ($got_seq);
		if (($take_len > $seqlen) && (!($got_name =~ m/PSEUDO/))) {
			$start_pt = rand ($take_len - $seqlen);
			$add_to_list = substr ($got_seq, $start_pt, $seqlen);
			$add_me = "0," . "C$got_name," . "$add_to_list";
			push (@outputList, $add_me);
			@frags = split ("$add_to_list", $got_seq);
			if (length ($frags[0]) > $seqlen) { push (@ORF_bin, [ ($got_name, $frags[0]) ]); }
			if (length ($frags[1]) > $seqlen) { push (@ORF_bin, [ ($got_name, $frags[1]) ]); }
			++$gotMembers[0];
		}
		last ORFBLOCK if !@ORF_bin;
	}
}	

UPSBLOCK: {
	while ($gotMembers[1] < $numMembers[1]) {
		($got_name, $got_seq) = CHOOSE (\@upstr_bin);
		if (!($got_name =~ m/PSEUDO/)) {
			$add_me = "1," . "U$got_name," . "$got_seq";
			push (@outputList, $add_me);
			++$gotMembers[1];
		}
		last UPSBLOCK if !@upstr_bin;
	}
}

my $got_pos;

FARBLOCK: {
	while ($gotMembers[2] < $numMembers[2]) {
		($got_pos, $got_seq) = CHOOSE (\@farup_bin);
		$take_len = length ($got_seq);
		if ($take_len > $seqlen) {
			$start_pt = rand ($take_len - $seqlen);
			$got_pos += $start_pt;
			$add_to_list = substr ($got_seq, $start_pt, $seqlen);
			@frags = split ("$add_to_list", $got_seq);
			if (length ($frags[0]) > $seqlen) { push (@farup_bin, [ ($got_pos - $start_pt, $frags[0]) ]); }
			if (length ($frags[1]) > $seqlen) { push (@farup_bin, [ ($got_pos + $seqlen, $frags[1]) ]); }
			if (rand 2 >= 1) { $add_to_list = REVCOMP ($add_to_list); }
			$add_me = "0," . "F$got_pos," . "$add_to_list";
			push (@outputList, $add_me);
			++$gotMembers[2];
		}
		last FARBLOCK if !@farup_bin;
	}
}

NONBLOCK: {
	while ($gotMembers[3] < $numMembers[3]) {
		($got_pos, $got_seq) = CHOOSE (\@nonup_bin);
		$take_len = length ($got_seq);
		if ($take_len > $seqlen) {
			$start_pt = rand ($take_len - $seqlen);
			$got_pos += $start_pt;
			$add_to_list = substr ($got_seq, $start_pt, $seqlen);
			@frags = split ("$add_to_list", $got_seq);
			if (length ($frags[0]) > $seqlen) { push (@farup_bin, [ ($got_pos - $start_pt, $frags[0]) ]); }
			if (length ($frags[1]) > $seqlen) { push (@farup_bin, [ ($got_pos + $seqlen, $frags[1]) ]); }
			if (rand 2 >= 1) { $add_to_list = REVCOMP ($add_to_list); }
			$add_me = "0," . "N$got_pos," . "$add_to_list";
			push (@outputList, $add_me);
			++$gotMembers[3];
		}
		last NONBLOCK if !@nonup_bin;
	}
}


print STDOUT "Set sizes obtained: C $gotMembers[0]  U $gotMembers[1]  F $gotMembers[2]  N $gotMembers[3]\n";

### Output to file

my $member;

open (OUT, ">$outfile");
foreach $member (@outputList) {
	print OUT "$member\n";
}
close (OUT);
