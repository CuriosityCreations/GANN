// oCscore.h: header file for oCscore.cpp
// GANN CORE
// Copyright (C) 1999-2004 Robert G. Beiko

// This program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public License
// as published by the Free Software Foundation; either version 2
// of the License, or (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

#include "classSelectableBase.h"

// oCscore holds and calculates the scores for a given (outer) Chromosome. An outer Chromosome (oC) contains a 
// series of inner Chromosomes (iCs), each specifying a neural network with identical parameters but different
// initial connection weights. The score of the oC depends on the performance of its constituent iCs.

// ABSTRACT BASE CLASS
class oCscore { 

public:

	oCscore (const int numInnerRounds); // Constructor

	virtual ~oCscore (); // Destructor

	virtual void nextConfig(const std::vector<double>& params, const int chrRound, const int Ogen, const int inNum) = 0;
	virtual void reset() = 0;

	void setWhyStop(const int toSet) { whyStop = toSet; } // Why did the network stop training?

	// Set member variables
	bool ifNewBestTime(const long aTime);
	virtual void setScoreDev(const int type, const int index, const double toSet) = 0;
	virtual void findBestScore(const bool isTest) = 0;
	bool recordScores(const double minGen);
	void nextInner() { ++innerRound; for (int i = 0; i < 4; ++i) roundScores[i] = 0.0;};
	
	// Return member variables
	long getTime() const { return theTime; }; // Return the training time
	int getChrID() const { return chrID; }; // Return which Chromosome is currently being trained
	double getScoreDev(const int type, const int index) const { return scoreDev[type][index]; };

	double getBestScore(const int type) const { return bestScores[type]; };

	double getBestScores(const int type, const int nthBest) const;

	// Output functions
	void startOfRound(const int numIn, const int numHid, const int numOut, const int theChr, 
		const int gen, const int howBig);	
	void endOfRound(const std::vector<double>& currentGAPar, const vector<int>& inputsToUse); // End-of-round score reporting
		virtual void paramInit() = 0;
		void paramOutput(const std::vector<double>& currentGAPar, const vector<int>& whichInputs);	
		virtual void chrScoresInit() = 0;
		virtual void chrScoresOutput(bool isEndOfRound) = 0; // Send a given group of scores or stdevs to outFile
	
protected:

	std::vector<double> scoreDev[4]; // Scores of constituent NNs
	
	// Indices:
	// 0: FP score, training set
	// 1: Distance score, training set
	// 2: FP score, test set
	// 3: Distance score, test set
	
	int nParams;

	long theTime; // The fastest time for an inner training round

	int totalRounds; // The number of training rounds to perform

	int chrID; // The position of this Chromosome in the outer GA
	int currentRound; // The current OGA training round
	int innerRound; // The current NN training round

	int size; // Total number of connection weights
	long chrConfig[3]; // Number of nodes in different layers
	
	int whyStop; // Why training stopped: 	(0) Normal exit
		     //		(1) Learning rate crashed
		     //		(2) Weights crashed
		     //		(3) Learning stuck

	ofstream oCoutputs[5]; // The output files generated by oCscore

	double roundScores[4]; // Best scores for current round
	double bestScores[4]; // Train FP, Train dist, Test FP, Test Dist: Best overall

	vector<double> bestRunsOfOC[4];
	double bestScoresOfOC[4];

};

// Derived class for backpropagation networks
class BPscore : public oCscore {

public:

	BPscore (const int numInnerRounds); // Null constructor

	~BPscore (); // Destructor

	void nextConfig(const std::vector<double>& params, const int chrRound, const int Ogen, const int inNum);
	void reset();
	
	// Output functions
	void paramInit();
	void chrScoresInit();
	void chrScoresOutput(bool isEndOfRound); // Send a given group of scores or stdevs to outFile

	// Set member variables
	bool ifNewBestNet(const int whichCheck); // Set a new best training Chromosome (!!! DEEP COPY !!!)

	void setScoreDev(const int type, const int index, const double toSet)
		{ scoreDev[type][index] = toSet; };
	
	void findBestScore(const bool isTest);

private:

};

// Derived class for genetic algorithm networks
class GAscore : public oCscore {
public:

	GAscore (const int numInnerRounds); // Null constructor

	~GAscore (); // Destructor
	
	void nextConfig(const std::vector<double>& params, const int chrRound, const int Ogen, const int inNum); // Set the number of Chromosomes/Evolvables to consider (and reset the object)
	void reset();

	// Output functions
	void paramInit();
	void chrScoresInit();
	void chrScoresOutput(bool isEndOfRound); // Send a given group of scores or stdevs to outFile	   

	// Set member variables
	bool ifNewBestNet(const int whichCheck);
	void setScoreDev(const int type, const int index, const double toSet) { scoreDev[type][index] = toSet; };
	void setScoreDev(const int type, const int evo, const int chr, const double toSet) { scoreDev[type][evo * numChr + chr] = toSet; };  // Set the training scores for a given iC

	// Return member variables
	int getSizeChr() const { return numChr; };  // Find out the number of chromosomes
	int getSizeEvo() const { return numEvo; };  // Find out the number of evolvables
	
	double getScoreOrDev(const int type, const int index) const { return scoreDev[type][index]; }; // Return a score or deviation from a training or test set
	double getScoreOrDev(const int type, const int evo, const int chr) const { return scoreDev[type][evo * numChr + chr]; };

	void findBestScore(const bool isTest); // Find best scores among all chr scores

private:

	int numEvo; // Number of evolvables
	int numChr; // Number of chromosomes per evolvable
};

